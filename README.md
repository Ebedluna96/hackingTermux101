![Portada Libro](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/portada.png)

-----

### Tabla de Contenidos

* [Prefacio](#prefacio)
* [Capítulo 0: Requisitos y Programas Extra](#cap%C3%ADtulo-0-requisitos-y-programas-extra)
* [Capítulo 1: Qué es Termux?](#cap%C3%ADtulo-1-qu%C3%A9-es-termux)
* [Capitulo 2: Descarga e Instalación](#capitulo-2-descarga-e-instalaci%C3%B3n)
* [Capítulo 3: Configuración Básica](#cap%C3%ADtulo-3-configuraci%C3%B3n-b%C3%A1sica)
* [Capítulo 4: Uso básico de la terminal](#cap%C3%ADtulo-4-uso-b%C3%A1sico-de-la-terminal)
* [Capítulo 5: Introducción a Bash](#cap%C3%ADtulo-5-introducci%C3%B3n-a-bash)
* [Capítulo 6: Uso de VI y de VIM](#cap%C3%ADtulo-6-uso-de-vi-y-de-vim)
* [Capitulo 7: Configuración de Bash](#capitulo-7-configuraci%C3%B3n-de-bash)
* [Capítulo 8: Sistema de Ficheros](#cap%C3%ADtulo-8-sistema-de-ficheros)
* [Capítulo 9: Creando comandos](#cap%C3%ADtulo-9-creando-comandos)
* [Capítulo 10: Comandos Intermedios](#cap%C3%ADtulo-10-comandos-intermedios)
* [Capítulo 11: Proot-Distro](#cap%C3%ADtulo-11-proot-distro)
* [Capitulo 12: Introducción a Sistemas Linux](#capitulo-12-introducci%C3%B3n-a-sistemas-linux)
* [Capitulo 13: Uso básico de Debian](#capitulo-13-uso-b%C3%A1sico-de-debian)
* [Capítulo 14: Uso básico de Ubuntu](#cap%C3%ADtulo-14-uso-b%C3%A1sico-de-ubuntu)
* [Capítulo 15: Uso básico de Alpine](#cap%C3%ADtulo-15-uso-b%C3%A1sico-de-alpine)
* [Capítulo 16: Uso básico de Fedora](#cap%C3%ADtulo-16-uso-b%C3%A1sico-de-fedora)
* [Capítulo 17: Introducción a Servicios](#cap%C3%ADtulo-17-introducci%C3%B3n-a-servicios)
* [Capítulo 18: Creando un Servidor](#cap%C3%ADtulo-18-creando-un-servidor)
* [Capítulo 19: Ngrok y Exponer Servicios](#cap%C3%ADtulo-19-ngrok-y-exponer-servicios)
* [Capítulo 20: Tor, Configuración y Uso](#cap%C3%ADtulo-20-tor-configuraci%C3%B3n-y-uso)
* Capítulo 21: Servicios Ocultos
* Capítulo 22: SSH, SHCP y SSHD
* Capítulo 23: Bots de Telegram
* Capítulo 24: Telegram RAT
* Capítulo 25: Protocolo HTTP
* Capítulo 26: Protocolo DNS
* Capítulo 27: Servicios Web
* Capítulo 28: Hosting Gratuitos
* Capítulo 29: Dominios Gratuitos
* Capítulo 30: Introducción a Programación
* Capítulo 31: Comparación de Lenguajes
* Capitulo 32: Introducción a C
* Capìtulo 33: Introducción a C++
* Capítulo 34: Introducción a C#
* Capítulo 35: Introducción a Go
* Capítulo 36: Introducción a Java
* Capítulo 37: Introducción a Javascript
* Capítulo 38: Introducción a Lua
* Capítulo 39: Introducción a PHP
* Capítulo 40: Introducción a Python
* Capítulo 41: Introducción a Rust
* Capítulo 42: Introducción a Node
* Capítulo 43: Introducción a Typescript
* Capítulo 44: Introducción a la Criptografìa
* Capítulo 45: Introducción al Malware
* Capítulo 46: Desarrollo de RATs
* Capítulo 47: Desarrollo de Ransomwares
* Capítulo 48: Desarrollo de Greyware
* Capítulo 49: Introducción a Hacking  
* Capítulo 50: Introducción a OSINT
* Capitulo 51: Google Hacking (dorks)
* Capitulo 52: Introducción a Hacking Web
* Capítulo 53: Introducción a Ingeniería Social
* Capítulo 54: Laboratorios y Páginas de Hacking legal.
* Capìtulo 55: HTMLi (inyección de HTML)
* Capítulo 56: XSS (Inyección de Javascript)
* Capítulo 57: CSFR (Peticiones entre sitios)
* Capítulo 58: Clickjacking (secuestro de clicks)
* Capítulo 59: HPP (Polución de parámetros HTTP)
* Capítulo 60: Open Redirects (redirecciones abiertas)
* Capitulo 61: SSRF (falsificación de peticiones en el lado del servidor)
* Capítulo 62: Path Traversal (recorrer rutas)
* Capítulo 63: Referrer Leaks (Filtraciones del referido)
* Capítulo 64: Dangling HTML (HTML pendiente)
* Capítulo 65: Subdomain/Domain Takeover (secuestro de sub/dominios)
* Capítulo 66: Template Injection (Inyección de plantillas)
* Capítulo 67: IDOR (Referencia a objecto indirecta)
* Capítulo 68: SQLi (Inyección del lenguaje de consultas estructurado)
* Capítulo 69: Cookie Tossing (lanzamiento de cookies)
* Capítulo 70: Web Cache Poisoning (envenenamiento de la caché web)
* Capítulo 71: Malas prácticas
* Capítulo 72: Post Explotación
* Capítulo 73: Herramientas de Hacking
* Capítulo 74: Dig
* Capítulo 75: Dirstalk
* Capítulo 76: Impulse
* Capítulo 77: ncat
* Capítulo 78: nmap
* Capítulo 79: nuclei
* Capítulo 80: searchsploit
* Capítulo 81: shodan
* Capítulo 82: sqlmap
* Capítulo 83: turbolist3r
* Capítulo 84: C++ intermedio
* Capítulo 85: Go intermedio
* Capítulo 86: Javascript intermedio
* Capítulo 87: PHP intermedio
* Capítulo 88: Python intermedio
* Capítulo 89: Node intermedio
* Capítulo 90: Quickjs intermedio
* Capítulo 91: Typescript intermedio
* Capítulo 92: Criptografía intermedio
* Capítulo 93: Malware intermedio
* Capítulo 94: Ingeniería Social intermedio
* Capítulo 95: Creando laboratorios y aplicaciones vulnerables
* Capítulo 96: Desarrollando aplicaciones de hacking
* Capítulo 97: Retos nivel basico
* Capítulo 98: Retos nivel intermedio
* Capítulo 99: Retos nivel avanzado
* Capítulo 100: Retos nivel 3l1t3
  
* Glosario
* Apéndice

-----

## Prefacio

Bienvenido a la primera edición del libro Termux Hacking 101. Aquí vas a aprender a instalar Termux en Android, su uso básico, virus, programación y hacking.  

Termux es un emulador de terminal para Android y un entorno de Linux que funciona directamente sin necesidad de rootear el dispositivo o configurarlo. Un sistema base mínimo se instala automáticamente - Y muchos paquetes adicionales están disponibles desde su gestor de paquetes.

[Tabla de Contenidos](#tabla-de-contenidos)  

-----

## Capítulo 0: Requisitos y Programas Extra

Para poder utilizar Termux, necesitas un dispositivo Android. Termux soporta versiones de **android** comprendidas **entre** la **versión 7 y** la **última version** de Android.  

Necesitas un **mínimo** de **300 megas de espacio** en disco. Yo te **recomiendo** como **mínimo 8 gigas disponibles de memoria interna**. 64 Gigas está genial y suele ser mas que suficiente, depende del uso que le des.  
  
Antes de empezar, algunos programas extra son recomendados, aunque no necesarios.
* [Hackers Keyboard](https://github.com/klausw/hackerskeyboard/releases/download/1.40.7/hackerskeyboard-v1.40.7.apk)  
Este sencillo teclado offline funciona de marabilla en la mayoría de dispositivos. No vende tus datos, ya que no se conecta nunca a internet y te ofrece un teclado como el del PC, aunque no es necesario. Yo no utilizo esta característica en concreto, pero si este es el único teclado que utilizo en Android por seguridad.  
  
Los que vienen preinstalados suelen vender tus datos aunque los configures para que no lo hagan.

* [Fx File Explorer](https://play.google.com/store/apps/details?id=nextapp.fx)  
Explorador de ficheros para Android que te permite el acceso a las carpetas de Termux. No lo he probado pero es recomendado por los desarrolladores de Termux.  

[Tabla de Contenidos](#tabla-de-contenidos)  

-----

## Capítulo 1: Qué es Termux?

Termux es una aplicación para Android de código abierto que trae todo el poder Linux a tu dispositivo móvil. Puedes realizar prácticamente cualquier tarea que realices en tu PC con un Linux instalado. Todo se realiza directamente desde la terminal escribiendo comandos, aunque también es posible [instalar](https://wiki.termux.com/wiki/Graphical_Environment) un entorno gráfico como X11.  
  
Termux instala por defecto un sistema base con comandos y paquetes comunes que suelen ser imprescindibles en cualquier distribución de Linux. Los paquetes se compilan de forma cruzada con Android NDK y en la mayoría de casos solo necesitan añadirle pequeños parches para que sean totalmente compatibles con Android. Hay miles de paquetes disponibles y cada día la comunidad añade nuevos paquetes.   
  
Es seguro, ya que todo es código abierto y miles de profesionales revisan el código y los nuevos cambios a diario.  

Tiene un montón de características extra, como poder ver los SMS, los archivos del dispositivo, etc. Esto te premite automatizar un montón de tareas, hacer interfaces con distintas tecnologías y todo lo que se te ocurra.  
  
Totalmente customizable. Puedes modificar la apariencia, añadir atajos de teclado, nuevas funcionalidades...  

Soporta teclado y ratón externos. Puedes conectar Termux a una pantalla externa y utilizar un teclado y un ratón. 

#### Cómo funciona?
La terminal emulada es básicamente una aplicación que arranca los programas de linea de comandos usando una llamada del sistema [execve(2)](https://www.man7.org/linux/man-pages/man2/execve.2.html) y redirige la entrada y la salida de datos de la función, hacia la pantalla.  
  
La mayoría de terminales para Android, trabajan con conjuntos de herramientas pobres que ya trae Android. Termux porta una gran cantidad de herramientas de GNU/Linux hacia Android. 

Termux no es una máquina virtual ni otro tipo de sistema/entorno emulado. Todos los paquetes son compilados en cruce con Android NDK y solo se parchean para que funcionen en Android/Termux.  
  
El sistema operativo no proporciona acceso completo al sistema de ficheros, por lo cual Termux no puede instalar los paquetes en las rutas típicas /bin, /etc, /usr, /var. Termux traslada este sistema de ficheros a un directorio privado de la aplicación en la ruta /data/data/com.termux/files/usr  
  
Este directorio se llama **prefix** y su ruta se puede visualizar en la variable de entorno "$PREFIX". Esta ruta se hardcodea directamente en muchos de los binarios/paquetes disponibles para Termux. Esto es uno de los típicos parches que se añaden.  

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capitulo 2: Descarga e Instalación

### Descarga
Puedes instalar Termux descargando la última [release](https://github.com/termux/termux-app/releases) directamente desde el repositorio del proyecto en github. O desde la tienda de [F-Droid](https://f-droid.org/en/packages/com.termux/).  
  
La descarga también está disponible en Play Store, pero descargar la app de la Play Store NO SE RECOMIENDA. El motivo está relacionado con políticas de Google con respecto a dar soporte a nuevas versiones de Android. Si se cumpliese con dichas políticas, habría que dejar de dar soporte a versiones anteriores. [Aquí mas detalles](https://github.com/termux/termux-app#google-play-store-deprecated).  
  
Si no conoces la arquitectura de tu dispositivo, puedes pinchar [aquí](https://stringmanolo.ml/hackingTermux101/paginas/mostrarArch.html).  
  
### Instalacion
- Abre F-Droid en tu Android pinchando [aquí](https://f-droid.org/packages/com.termux/) 
- Pincha en el primer enlace que dice [Descargar Apk]()  
- Pincha en el archivo descargado para iniciar la instalación  
- Pincha en Permitir instalación de aplicaciones desde orígenes desconocidos  
- Espera a que se complete la instalación  
- Cuando finalice la instalación tendrás el icono de Termux en tu escritorio, haz click para arrancar la app.
  
[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 3: Configuración Básica

Una vez tienes la consola de comandos ante ti, lo primero es configurar el acceso al sistema interno de ficheros de Android. Para ello debes correr el comando
```bash
termux-setup-storage
```
Y permitir el acceso de termux al sistema interno de ficheros.   

![Imagen de Android que pide permisos de acceso al espacio interno de ficheros](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/termux-setup-storage.png)
  
El comando **termux-setup-storage** va a configurar el acceso a las siguientes carpetas.  
* ~/storage/shared  
Carpeta utilizada por las aplicaciones de Android para compartir archivos  
* ~/storage/downloads  
La carpeta por defecto de descargas, por ejemplo donde tu navegador descarga los archivos.  
* ~/storage/dcim  
Aquí la cámara suele almacenar las fotos y videos del dispositivo  
* ~/storage/pictures  
En esta carpeta se suelen almacenar imágenes del dispositivo
* ~/storage/music  
Esta es la carpeta que Android suele utilizar para guardar la música del usuario
* ~/storage/movies  
Donde se suelen almacenar las películas
* ~/storage/external-1  
Carpeta especial creada por Termux en el almacenamiento externo (si este está disponible), normalmente una tarjeta micro-sd, aunque se permite también el acceso a pendrives y otro tipo de dispositivos de memoria externos. No instales paquetes, programas o archivos de programas aquí (como puedan ser logs de un servidor, archivos de configuración, ...) , ya que Android no proporciona permisos de escritura/lectura directamente y es necesario utilizar una API a la que los programas no tienen acceso.

Si utilizas Android 11 y se muestra el error __Permission denied__ (Permiso denegado) cuando intentas acceder a la carpeta shared, aún cuando le diste permisos, sigue los pasos siguientes:
- Ve a Ajustes -> Aplicaciones -> Termux -> Permisos
- Revoca el permiso de acceso a ficheros (Storage permission)
- Autoriza de nuevo el permiso de acceso a ficheros.

Este es un bug de Android 11, no de Termux.

> Nunca elimines Termux directamente desde Android, ya que si tienes archivos en la tarjeta sd, todo su contenido será eliminado, incluyendo archivos que no tienen ninguna relación con Termux

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 4: Uso básico de la terminal

Una terminal es una interfaz conducida por comandos capaz de realizar todo tipo de tareas. Usualmente realizamos las tareas utilizando interfaces, esto es, pulsando botones, arrastrando carpetas, viendo la información en forma de imágenes e iconos... La terminal utiliza un modelo completamente distinto, remplazando los iconos, las imágenes, los botones y toda la gestión de ficheros por comandos y texto que se muestra en pantalla.  

Utilizar una terminal en lugar de una interfaz gráfica, nos permite realizar tareas de todo tipo de forma mas ágil y rápida.  

Todas las terminales de GNU/Linux, así como Termux, incluyen una gran variedad de comandos básicos que nos permiten realizar estas tareas. Este capítulo se enfoca en los comandos más básicos de Linux.  
  
Al entrar en Termux, veremos un **$** que indica el "prompt" de la terminal, en Bash se guarda en la variable de entorno "$PS1". Este caracter del dolar, nos indica que podemos escribir comandos en la terminal. La sintaxis es **$ comando**, para enviar el comando y que este sea procesado, pulsamos la tecla Enter. En caso de Hacker's Keyboard, esta tecla se representa como una flecha situada en la esquina inferior derecha **⏎**.  

### Comandos básicos de Linux

#### pwd  
El comando **pwd** nos va a mostrar la ruta completa de la carpeta en la cual nos encontramos.  
  
![Salida del comando pwd](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/pwd.jpg)  

> pwd son las siglas de Print Working Directory (Imprime Directorio de Trabajo)

#### cd  
El comando **cd** sirve para cambiar el directorio en el cual estamos trabajando. Es el equivalente a moverse a una carpeta haciendo doble-click en ella desde cualquier interfaz gráfica.  
Si escribes el comando cd sin mas, se cambiará el directorio a la variable de entorno "$HOME", por defecto /data/data/com.termux/files/home.  
  
> Existe un símbolo especial **~** que sirve para indicar explícitamente que nos mueva a la carpeta home. Esto nos será útil cuando queramos crear o referenciar un archivo en home desde otro directorio.  
  
Podemos movernos a cualquier directorio alcanzable poniendo su ruta relativa tras el comando cd, o poniendo su ruta absoluta desde cualquier lugar. En la siguiente imagen puedes comprobar como se cambia el directorio a la carpeta __ejemplo__, que existe dentro de la carpeta home, y como después se imprime el directorio actual de trabajo. Indicándonos la terminal, que nos encontramos dentro de la carpeta ejemplo que existe en home.

Cuando quieras moverte al directorio anterior utiliza dos puntos.
```bash
cd ..
```
  
![Salida del comando cd ejemplo y pwd](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/cd_ejemplo.jpg)  

> cd son las siglas de Change Directory (Cambia Directorio), 

#### ls  
El comando **ls** muestra la lista de archivos y carpetas que contiene el directorio actual de trabajo.  
  
![Salida del comando ls y pwd](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/ls.jpg)  
  
En este ejemplo nos movemos al directorio home, desde ahí al directorio ejemplo que está dentro de home y con **ls** listamos todo lo que contiene el directorio actual.  
  
En blanco se muestran los archivos comunes (foto_perfil.jpg, listaDeLaCompra.txt), en azul/violeta se muestran los directorios que contiene el directorio __ejemplo__. En este caso hay un directorio llamado __documentosDelTrabajo__. En verde se muestran archivos con permisos de ejecución, en esta imagen no hay ninguno.  
  
> ls es una abreviatura de List (Listar)  

#### cat
El comando **cat** muestra el contenido de un fichero.
  
![Salida del comando cat](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/cat.jpg)  
  
En este ejemplo se muestra el contenido del fichero listaDeLaCompra.txt. Es simplemente un texto que escribí en un fichero. La escritura de ficheros se detalla en el [capítulo 6: Uso de VI y de VIM](#cap%C3%ADtulo-6-uso-de-vi-y-de-vim).
  
> cat viene de concatenate (concatenar)  
  
#### touch
El comando **touch** crea ficheros vacios en el directorio actual.  
```bash
touch miListaDeLaCompra.txt
```
  
Con este comando crearás un archivo miListaDeLaCompra.txt en el directorio actual, que podras ver en el listado del directorio en el que crees el archivo. Por ejemplo si quisieses crear el archivo en home y listar el contenido de home, usarías los siguientes comandos:  
```bash
cd
touch miListaDeLaCompra.txt
ls
```
   
> touch significa tocar

#### mkdir
El comando **mkdir** crea directorios/carpetas vacias en el directorio actual.  
```bash
cd
mkdir ejemplo
```  
  
Con estes comandos crearás una carpeta (puedes usar el nombre de carpeta/directorio indistintamente) llamada __ejemplo__ dentro de la carpeta home. Puedes listarla con ls.   

Si intentas crear un nuevo directorio y un directorio hijo directamente, puede usar el argumento -p (de parents, en español directorios padres)  

```bash
mkdir ~/ejemplo/hijoDeEjemplo/hijoDeHijoDeEjemplo
```


> mkdir es una abreviatura de Make Directory (Crea Directorio)

#### cp
El comando **cp** permire copiar archivos. Puedes copiarlos en el mismo directorio o en otro directorio. Tambien puedes modificar el nombre de destino.
```bash
cp miListaDeLaCompra.txt miSegundaListaDeLaCompra.txt
```
  
El primer argumento del comando **cp** es el nombre del fichero del que deseamos realizar una copia. El segundo argumento es el nuevo nombre que tendrá la copia. Si el archivo contiene texto o cualquier otro contenido, este estará presente en ambos archivos, tanto en el original como en la copia.  
  
La mayoría de comandos nos permite especificar las ruta junto al nombre de los ficheros. Si nos encontramos en la carpeta home, y dentro de esta tenemos una carpeta llamada ejemplo que contiene un archivo miListaDeLaCompra.txt, podemos copiar este archivo directamente desde la carpera home. El comando para realizar esta acción sería:  
  
```bash
cd
cp ejemplo/miListaDeLaCompra.txt listaDeLaCompra.txt
```

Tras este comando tendremos una copia del archivo miListaDeLaCompra.txt (que se encuentra en la carpeta ejemplo) en la carpeta home con el nombre de listaDeLaCompra.txt  

> cp es una abreviatura de copy (copiar)

#### mv
El comando **mv** permite mover archivos. El funcionamiente es exactamente igual al del comando **cp**, con la diferencia de que el archivo original es eliminado y solo se conserva la nueva copia.  
  
Esto hace de **mv** el comando ideal para mover archivos entre directorios.  
  
> mv es una abreviatura de move (mover)  

#### rm
El comando **rm** se utiliza para eliminar archivos de forma permanente.  
  
```bash
cd
rm listaDeLaCompra.txt
```

> rm es una abreviatura de remove (eliminar)

#### clear
El comando **clear**, limpia el contenido de la pantalla.
```bash
clear
```
  
> clear significa limpiar  
  
#### pkg
El comando **pkg** es único de Termux, no existe en GNU/Linux, aunqie si existen sus equivalentes. Este comando se encarga de gestionar por nosotros toda la instalación de paquetes, sus versiones, actualizaciones, dependencias, ...  
  
Si corres el comando:
```bash
pkg
```

Te mostrará la lista de subcomandos que soporta y una breve descripción de que hace cada uno. Aquí me limito a explicar los subcomandos mas básicos:  

* ##### pkg list-all  
Muestra un listado todos los comandos/programas/paquetes disponibles para instalar. El listado es bastante grande.  
```bash 
pkg list-all
```

* ##### pkg list-installed  
Muestra el listado de los comandos que ya están instalados en tu Termux. Este listado solo hace referencia a paquetes que se han instalado por **pkg**. Esto significa que no verás en la lista comandos como cp, cat, mv, ls, ... También significa que puedan aparecer algunos paquetes que tu no instalases.  
  
Por ejemplo si instalas una herramienta que utiliza una base de datos, es común que en el listado te aparezcan tanto la herramienta que descargaste como la base de datos. Esto sucede porque pkg se encarga de bajar las dependencias necesarias (para que las herramientas funcionen) por su cuenta.  
```bash
pkg list-installed
```

* ##### pkg show
Muestra información adicional incluyendo una breve descripción sobre el paquete que se indique. Puedes utilizar el nombre de cualquiera de los paquetes listados con los 2 anteriores subcomandos
```bash
pkg show unzip
```

El comando **pkg show unzip** nos muestra esta descripción para el comando unzip.
```
Package: unzip
Version: 6.0-7
Maintainer: Termux members @termux
Installed-Size: 340 kB
Depends: libbz2
Homepage: https://sourceforge.net/projects/infozip/
Download-Size: 115 kB
APT-Manual-Installed: yes
APT-Sources: https://termux.org/packages stable/main aarch64 Packages
Description: Tools for working with zip files
```

En este ejemplo la información que se nos muestra indica:  
- El nombre del paquete  
- La versión del programa  
- Las personas/organización que se encargan de gestionar este paquete
- El tamaño que ocupará en el sistema una vez instalado  
- Otros paquetes que necesita para funcionar
- La página oficial del programa (o repositorio de su código fuente)
- El tamaño de la descarga comprimida
- Si se instaló manualmente
- Repositorio donde está el paquete listado
- Descripción de que es el paquete
  
Si tienes la opción de buscar en Google el paquete, te será de mas ayuda para saber exactamente para que sirve.

* ##### pkg install
Instala un comando en Termux.  
```bash
pkg install tree
```

Una vez instalado, ya podras utilizarlo. Tree es similar a ls pero también muestra todos los subdirectorios.
```bash
tree
```

* ##### pkg uninstall
Desinstala un comando en Termux.
```bash
pkg uninstall tree
```

Una vez desinstalado, se borrará permanentemente del sistema el comando que hayas escrito en este caso tree. Si intentas volver a utilizarlo tras desinstalarlo, verás que ya no existe.  
  
Puedes borrarlo si quieres, siempre podrás volver a instalarlo si lo necesitas.

* ##### pkg upgrade
Actualiza todos los paquetes instalados.
```bash
pkg update
```

> Si tienes espacio de sobra, es recomendado que todos los días actualices tus comandos usando **pkg upgrade** Las actualizaciones, sirven principalmente para mantener tus paquetes seguros.
> Cuando un programador o hacker, encuentra un fallo de seguridad en un programa, se programa un código (parche de seguridad). Cuando tu le das a actualizar, se instalan estos parches automáticamente. También se instalan parches de mejoras de rendimiento para que los comandos se ejecuten mas rápido o utilicen menos batería, asi como también nuevas funcionalidades. 

#### man
El comando **man** sirve para mostrar el manual de un comando, si lo tiene.
```bash
man ls
```

Con **man ls** se nos muestra el manual para el comando ls, con todas sus opciones extra.  
  
> man son la iniciales de manual

#### exit
Cierra la terminal


#### Argumentos
Los comandos de GNU/Linux aceptan argumentos especiales que van precedidos de guiones. Hay 2 formas de argumentos con guiones. La forma corta y la forma léxica del argumento. La forma corta es siempre una letra, normalmente la inicial de la forma léxica.  
  
Uno de los argumentos que vamos a encontrar presentes en prácticamente todos los comandos es **-h**. Versión corta de **--help**. Normalmente podemos acompañar nuestros comandos de cualquiera de estos indistintamente, aunque no hay ninguna norma escrita y muchos desarrolladores muestran distintos mensajes de ayuda según utilizas la versión corta o la léxica. Yo suelo dar prioridad a las opción léxica del argumento help.

```bash
ls --help
```



[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 5: Introducción a Bash
Bash es una shell de comandos. Todos los comandos que usamos hasta ahora, han sido enviados a Bash y Bash es quien se ha encargado de interpretarlos y llamar a los paquetes correspondientes. Se encarga de procesar el texto que le introducimos y el símbolo dolar **$** nos está indicando que se trata de una Shell normal.  

> En Linux cuando eres root usando el comando **sudo su** el dolar se cambia por un hash (asterisco) #. En Android no disponemos de root por defecto, y este libro asume que no eres root. Es posible obtenerlo, pero yo no lo recomiendo en Android por motivos de seguridad del sistema.   
  
Bash no es un simple intérprete, si no que admite un gran número de instrucciones muy diversas y tambien algunas complejas, dando lugar a un lenguaje de programación potente ampliamente utilizado para configurar sistemas GNU/Linux, crear comandos y otro tipo de utilidades.

#### Variables
Las variables te permiten almacenar valores para poder utilizarlos mas adelante.  
  
Para almacenar texto en una variable usaremos la siguiente sintaxis **nombreDeLaVariable**="__valorDeLaVariable__"   
```bash
miNombre="Manolo"
```
  
También es posible almacenar el resultado de un comando en la variable utilizando la sintaxis **nombreDeLaVariable**=__$(comando argumentos)__  
```bash
listaArchivosEnHome=$(ls ~)
```

Podremos referenciar la variable anteponiendo el símbolo del dolar al nombre de la variable, como veremos en el siguiente apartado.

#### Imprimir en pantalla
Para imprimir texto o el contenido de variables (en este caso en pantalla) podemos utilizar echo o printf.  
  
##### echo  
echo es un comando sencillo para imprimir texto  
```bash
miNombre="Manolo"
echo "Hola, mi nombre es $miNombre"
```

Puedes usar variables como en el ejemplo anterior, y también comandos:
```bash
echo "Hola, te encuentras en el directorio $(pwd)"
```  
  
Si quieres que se imprima un salto de linea, puedes anteponer el argumento simple -e del texto. Y en el texto incluyes la secuencia de caracteres \n para indicar un salto de linea.  
```bash
echo "$(clear)\n\n\n\n\n\n\n\n\n\nHola, te encuentras en el directorio\n$(pwd)\nNo es genial\n?\n\n"
```
  
![Salida del comando echo en multiples lineas](https://github.com/StringManolo/hackingTermux101/raw/master/imagenes/echo.jpg)  
  
##### printf
printf hace lo mismo que echo pero se ejecuta mas rápido y permite mas opciones para formatear el texto.  
```bash
miNombre="Manolo"
printf "Hola, mi nombre es %s" "$miNombre"
```

Con respecto a echo, puedes apreciar que no se añade el salto de linea al final de la frase. Tienes que añadirla manualmente. También ves en el comando que las variables se separan en otros argumentos a parte. En este caso %s indica que la variable es un string (cadena de texto).  
  
Otra de las ventajas de printf, es que nos avisa de errores. Por ejemplo %d sirve para imprimir numeros enteros. Si le pasamos como argumento un numero que no es entero, nos avisará del error  
```bash
numeroPI="3.1416"
printf "El numero PI es %d" "$numeroPI"
```

Bash nos indicará el error: **bash: printf: 3.1416: invalid number** e imprimirá solo la parte entera.  Esta es la lista de tipos que acepta:

|  secuencia   |    tipo     | descripción                                             |
|      ---     |     ---     |                           ---                           |
| %d           | digit       | Números enteros                                         |
| %f           | float       | Números flotantes (numeros con decimales)               |
| %s           | string      | Cadena de texto                                         |
| %x           | hexadecimal | Imprime un número en hexadecimal                        |
| %X           | hexadecimal | Imprime un número en hexadecimal (letras en mayúsculas) |
 

#### Leer de la terminal  
Podemos interactura con el usuario de múltiples formas.

##### read  
El comando **read** nos permite leer datos de la entrada de la terminal. Nosotros usaremos read con el argumento simple -p (la p es de la palabra prompt, en español sugerencia) y nos srive para sugerir al usuario el tipo de datos que queremos que introduza.  
  
Si por ejemplo queremos preguntarle el nombre al usuario
```bash
read -p "Cómo te llamas? " nombre
echo "Tu nombre es $nombre"
```  
  
En este ejemplo vemos que readme se parece a echo, pero admite un argumento extra, que será el nombre de la variable en la cual queremos que se guarden los datos que introduzca el usuario.  
  
> read significa leer

#### Condicionales  
Los condicionales permiten realizar acciones si se cumple una condición. **if [ condición ]; then comando fi**. En español se traduciría a algo similar a **sì [ seCumpleEstaCondición ]; entonces ejecutaEsteComando fin**. Podemos ver un ejemplo.

```bash
read -p "Introduce tu edad y pulsa enter: " edad
if [ "$edad" -gt 17 ]; then
  echo "Eres mayor de edad"
fi
```

En este ejemplo tenemos:
- Un read  
Almacena la edad que introduce el usuario en la variable edad.  
- La palabra clave if  
Indica que la expresión es un condicional
- Unos corchetes (que también son comandos, aunque no lo parezcan)  
Evaluan la siguiente expresión y delimitan donde empieza ([) y acaba (]) la condición  
- El punto y coma (;)  
Sirve para indicar el final de los comandos asociados a if  
- La palabra then  
Indica que a continuación vienen las instrucciones que queremos que se ejecuten si se ha cumplido la condición.  
- Un echo que imprime un texto  
Aunque podría ser cualquier otro comando, asignación de variables, etc.  
- Y la palabra fi (es if al revés)
Indica el final del condicional  
  
La condición **"$edad" -gt 17** está compuesta de 3 elementos:  
- "$edad"
Es una variable que contiene la edad del usuario
- -gt
Es un operador especial de Bash, siglas de Greater Than (Mayor Que). Sería equivalente al operador matemático **>**  
- 17  
Si la edad del usuario es mayor que 17, entonces es mayor de edad (18 años o más en mi país)  
  
Recuerdas que te dije que **[** era un comando mas? Igual que echo o printf. Pues **[** también tiene argumentos.
Hay distintos tipos de condiciones, aquí un listado de las mas comunes:  
```bash
[ -a listaDeLaCompra.txt ]  
```
Se cumple si el archivo existe  
  
&nbsp;  
  
```bash
[ -d ejemplo ]  
```
Se cumple si la carpeta existe  
  
&nbsp;  
  
```bash
[ -f listaDeLaCompra.txt ]  
```
Se cumple si el archivo existe y es un archivo normal  
  
&nbsp;  

```bash
[ -s listaDeLaCompra.txt ]  
```
Se cumple si el archivo existe y no está vacio   
  
&nbsp;  
  
```bash
[ listaDeLaCompra.txt -nt otraListaDeLaCompra.txt ]  
```
Se cumple si el primer archivo es mas reciente que el segundo  
> nt abreviado de newer than (mas nuevo que)   
  
&nbsp;  
  
```bash
[ listaDeLaCompra.txt -ot recetaChurros.txt ]   
```
Se cumple si el primer archivo es mas viejo que el segundo  
> ot abreviado de older than (mas viejo que)  
  
&nbsp;  
  
```bash
[ -z "$nombre" ]
```
Se cumple si la variable está vacia   
  
&nbsp;  
  
```bash
[ -n "$nombre" ]  
```
Se cumple si la variable no está vacia  
  
&nbsp;  
  
```bash
[ "$nombre" = "Paco" ]
```
Se cumple si el contendio de la variable **$nombre** es **Paco**  
  
&nbsp;  
  
```bash
[ "$nombre" != "Paco" ]
```
Se cumple si el contenido de la variable **$nombre** no es **Paco**  
  
&nbsp;  

```bash
[ "$nombre" < "Paco" ]  
```
Se cumple si el contenido de la variable **$nombre** se posiciona antes que Paco, alfabéticamente  
  
&nbsp;  
   
```bash
[ "$nombre" > "Paco" ]  
```
Se cumple si el contenido de la variable **$nombre** se posiciona después que Paco, alfabéticamente  
  
&nbsp;  
   
```bash
[ -v "$nombre" ]
```
Se cumple si la variable existe  
  
&nbsp;  
  
```bash
[ ! condicion ]
```
Se cumple si la condición no se cumple  
  
&nbsp;  

```bash
[ condicion -o otraCondicion ]
```
Se cumple si cualquiera de las 2 condiciones se cumple (o ambas se cumplen)  
  
&nbsp;  

```bash
[ condicion -a otraCondicion ]
```
Se cumple solo si ambas condiciones se cumplen  
  
&nbsp;  

```bash
[ 7 -eq 7 ]  
```
Se cumple si el primer número es igual al segundo (recuerda que puedes usar variables)  
> eq de equals (igual a)  
  
&nbsp;  

```bash
[ 7 -ne 7 ]
```
Se cumple si el primer número es distinto al segundo   
> ne de not equal (no igual a)  
  
&nbsp;  

```bash
[ 7 -lt 7 ]
```
Se cumple si el primer numero es menor que el segundo  
> lt de less than (menor que)  
  
&nbsp;  
  
```bash
[ 7 -le 7 ]  
```
Se cumple si el primer número es menor o igual al segundo  
> le de less equal (menor o igual a)  
  
&nbsp;  

```bash
[ 7 -gt 7 ]  
```
Se cumple si el primer número es mayor que el segundo  
> gt de greater than (mayor que)  
  
&nbsp;  

```bash
[ 7 -ge 7 ]
```
Se cumple si el primer número es mayor o igual que el segundo  
> ge de greater equal (mayor o igual a)  
  
&nbsp;  

A parte de if, hay un par de palabras mas que podemos utilizar en los condicionales.  
El comando **else** permite ejecutar comandos si la condición no se ha cumplido. Queda mas claro con un ejemplo:
```bash
read -p "Introduce tu edad y pulsa enter: " edad
if [ "$edad" -gt 17 ]; then
  echo "Eres mayor de edad"
else 
  echo "Eres menor de edad"
fi
```

Si pruebas el ejemplo pegándolo en tu terminal y pulsando enter, verás que si se cumple la condición mostrará el texto indicando que eres mayor de edad, y si no se cumple, te dirá que eres menor de edad.  
  
La última palabra clave es **elif**, y sirve para introducir mas if, que se ejecutarán solo si el anterior **if** no se cumple. Ejemplo:
```bash
read -p "Introduce tu edad y pulsa enter: " edad
if [ "$edad" -lt 12 ]; then
  echo "Eres un niño"
elif [ "$edad" -lt 18 ]; then
  echo "Eres un adolescente"
elif [ "$edad" -lt 65 ]; then
  echo "Eres un adulto"
else 
  echo "Eres un anciano"
fi
```

En español esto viene diciendo:
```bash
si (tienes menos de 12 años) entonces
  muestra "Eres un niño"
en caso contrario, si (tienes menos de 18 años) entonces
  muestra "Eres un adolescente"
en caso contrario, si (tienes menos de 65 años) entonces
  muestra "Eres un adulto"
en caso contrario 
  muestra "Eres un anciano"
```

El comando *case* es una forma distinta de crear condicionales, en otros lenguajes se le conoce como **switch** o también **switch case** y se utiliza principalmente cuando quieres comprobar la variable con valores concretos
```bash
printf "1. Imprimir Directorio Actual\n2. Listar ficheros \n3. Crear Archivo\n4. Crear Carpeta\n\n0. Salir\n\nSelecciona el número correspondiente a tu opción -> "
read opcion
case $opcion in 
  1)
    echo $(pwd) 
  ;;

  2)
    echo $(ls)
  ;;

  3)
    read -p "Introduce el nombre que tendrá el nuevo fichero: " nombreFichero
    touch $nombreFichero
  ;;

  4)
    read -p "Introduce el nombre que tendrá el nuevo directorio: " nombreDirectorio
    mkdir $nombreDirectorio
  ;;

  0)
    echo "Adios" 
  ;;
   
  *)
    echo "La opción que elegiste no existe"
  ;;
esac
```

#### Bucles
Los bucles nos permiten correr un comando/realizar una tarea de forma repetida.  
Existen 4 tipos de bucles basicos en Bash. Los bucles **while**, **until**, **for** y **select**.   
  
##### while
El comando **while** permite ejecutar comandos mientras la condición sea verdadera. Su sintaxis es similar a la del condicional **if**. Ejemplo:
```bash
read -p  "Introduce tu contraseña: " contra
while [ "$contra" != "admin123" ]; do
  read -p "La contraseña '$contra' es incorrecta. Inténtalo de nuevo: " contra
done
echo "Acceso Permitido"
```

> Si no supieses la contraseña, no sabrías como salir del programa. Cuando quieras cancela la ejecución de un programa que está en bucle, presiona las teclas **CTRL** y **c**. Si no funciona, prueba con las teclas **CTRL** y **d**. 
  
##### until 
El bucle **until** es prácticamente igual al bucle **while**, con la diferencia de que se ejecutará mientras no se alcance la condición.  
```bash
read -p  "Introduce tu contraseña: " contra
until [ "$contra" = "admin123" ]; do
  read -p "La contraseña '$contra' es incorrecta. Inténtalo de nuevo: " contra
done
echo "Acceso Permitido"
```

> Puedes usar while o until indistintamente. Until existe simplemente porque puede ser mas sencilla de leer la expresión en inglés.  
Los ejemplos anteriores en español dirían; Para **while**:
> Mientras (laContraseña no es igual a "admin123") haz ...  
Para **until**:  
> Hasta que (laContraseña no sea igual a "admin123") haz ...
  
##### for
El bucle for sirve principalmente para recorrer elemenos. Los elementos pueden ser frases, palabras, secuencias numéricas, etc.  
```bash
frase="Hola me llamo Manolo"
echo "La frase '$frase' tiene las siguientes palabras:"
for palabra in $frase; do
  echo "$palabra"
done
```

Lo mismo que haces con palabras, puedes hacerlo directamente con la salida de comandos. Da mucho juego  
```bash
for archivo in $(ls ~); do
  echo "$archivo"
done
```
  
&nbsp;  
También puedes recorrer rangos de números
```bash
echo "Los números del 1 al 20 son:"
for numero in {1..20}; do
  printf "%d, " $numero
done
```
  
&nbsp;  
Si queremos omitir la última coma tras el 20, podemos usar un condicional:  
```bash
echo "Los números del 1 al 20 son:"
for numero in {1..20}; do
  if [ "$numero" -ne 20 ]; then
    printf "%d, " $numero
  else 
    printf "%d" $numero
  fi
done
```

Hay otra forma de usar el **for** que le será familiar a quien utilice el for en otros lenguajes de programación. Esta versión del **for** se le conoce como **for clásico**  
```bash
for ((i=1; i <= 10; i++)) do
  echo "$i"
done
```

Algunos lenguajes de programación no disponen del bucle **for clásico**, pero si tienen el **while**. Hay una forma simple de conseguir esta misma funcionalidad con el bucle **while** 
```bash
i=1
while [ $i -le 10 ]; do
  echo "$i"
  ((++i))
done
```

##### select
El bucle **select** es un tipo de bucle ideal para hacer menus de forma sencilla.
```bash
opciones="Sumar Restar Multiplicar Dividir Salir"
select opcion in $opciones; do
  if [ "$opcion" = "Salir" ]; then
    echo "Adios"
    break
  fi

  read -p "Introduce el primer número: " primerNumero
  read -p "Introduce el segundo número: " segundoNumero
  if [ "$opcion" = "Sumar" ]; then
    resultado=$(( $primerNumero + $segundoNumero ))
  elif [ "$opcion" = "Restar" ]; then
    resultado=$(( $primerNumero - $segundoNumero ))
  elif [ "$opcion" = "Multiplicar" ]; then
    resultado=$(( $primerNumero * $segundoNumero ))
  elif [ "$opcion" = "Dividir" ]; then
    resultado=$(( $primerNumero / $segundoNumero ))
  else
    resultado="Opcion incorrecta."
  fi

  echo "El resultado es $resultado";
done
```

En este ejemplo podemos ver una calculadora simple en Bash. A destacar la palabra **break** que sirve para salir de cualquier tipo de bucle. 

##### funciones
Las **funciones** en Bash nos permiten agrupar varias instrucciones bajo el mismo nombre y son similares a los comandos en su uso. Para crear una función:  
  
```bash
saludar() {
  echo "hola $1, bienvenido a mi programa"
}
```

De esta forma creamos una función que podremos reusar las veces que queramos. La principal utilidad de las funciones es reducir el tamaño del código.
```bash
saludar() {
  echo "hola $1, bienvenido a mi programa"
}

saludar "Manolo"
saludar "Arturo"
```

Como puedes ver, puedes saludar a tantos usuarios como quieras sin necesidad de tener que escribir el mismo texto una y otra vez. Puedes poner cualquier tipo de comandos dentro de las funciones.

Si quieres que quede mas claro que estás creando una función, puedes usar la palabra clave **function** y omitir los paréntesis:
```bash
function saludar {
  echo "hola $1, bienvenido a mi programa"
}

saludar "Manolo"
saludar "Arturo"
```

Puedes usar cualquier de las 2 formas, la que tu prefieras. A destacar el uso del dolar. Sirve para referenciar argumentos. $1 referencia el primer argumento. Puedes utilizar todos los que tu quieras:
```bash
saludar() {
  echo "Quiero dar la bienvenida a $1, $2 y $3" 
}

saludar "Manolo" "Arturo" "Jose"
```

#### Miscelanea (otros operadores)
Bash permite realizar redirecciones entre comandos, salida a pantalla, entrada a comandos y ficheros. Una redirección es el envio de texto desde un fichero a otro. Todo lo que vemos en pantalla en realidad es enviado a un fichero de texto y Bash se encarga de imprimir su contenido para que lo veamos.  

##### >
El caracter **>** nos permite enviar la salida de un comando hacia un fichero. Si el nombre del fichero no existe, se creará uno nuevo.
```bash
echo -e "Lista de la compra:\n2 paquetes de letejas\n1 cartón de leche" > ~/miListaDeLaCompra.txt
```

Con el **>** indicamos que en lugar de mostrar el texto en pantalla queremos que se mande al archivo __miListaDeLaCompra.txt__ que está ubicado en la carpeta **~** (home). Si el archivo no existe **>** se encarga de crearlo antes de volcar la salida del comando **echo**, y si este archivo ya existía en home, se le borrará todo el contenido antes de añadir el nuevo contenido  
  
Ahora puedes imprimir su contenido cuando quieras
```bash
cat ~/miListaDeLaCompra.txt
```

> La extensión .txt no hace nada, ninguna extensión hace nada en particular. Solo se añaden para ayudar al usuario o a otros programas a intuir que tipo de datos puede contener el fichero.   
  
Otro uso común es ocultar la salida de un comando. Para ello redirigimos la salida a un archivo especial diseñado para ello.
```bash
echo "Hola" > /dev/null
```

Redirigir a __/dev/null__ es una práctica común cuando queremos correr un comando pero no nos interesa lo que nos muestre. Puede ser el caso de un servidor de una página web cuando muestra los logs en pantalla y no nos interesan.  

Aunque redirigas la salida a __/dev/null__ los comandos siguen mostrando los errores en pantalla si estos se dan. Si quieres ocultar los errores, debes redirigir un archivo especial hacia __/dev/null__  

```bash
cat esteArchicoNoExiste.txt 2>/dev/null
```

##### >>
Qué pasa si quiesieses añadir un nuevo producto a tu lista de la compra sin eliminar el contenido del fichero? Se utiliza el operador **>>** en lugar de **>**. Al igual que **>**, si no existe el fichero también se creará, pero si ya existe el fichero, en lugar de remplazar su contenido por el nuevo que indiquemos, se añadirá al que ya existe.
```bash
echo -e "\n6 latas de mejillones" >> ~/miListaDeLaCompra.txt
```
  
> Puedes redirigir la salida de cualquier comando, no solo de echo  

##### <

##### <<

##### |
El operador **|** sirve para redirigir la salida de un comando hacia otro comando.  
Existen una multitud de utilidades que son perfectas para su uso con **|**
```bash
echo "Hola qué tal?" | wc  
```

> El comando **wc** (word counter en español, contador de palabras) muestra el número de lineas, palabras y caracteres que tiene un texto. En este caso el texto lo pasamos del comando **echo** hacia el comando **wc** utilizando **|**


##### ||
El operador **||** (OR) sirve para ejecutar un comando si el anterior falla.
```bash
cat esteArchivoNoExiste.txt || echo "El archivo no existe"
```

Es común redirigir los errores a __/dev/null__ y mostrar nuestros errores personalizados  
```bash
cat archivoQueNoExiste 2>/dev/null || echo "No se pudo mostrar el contenido del archivo"
```

##### &

##### &&

#### help
[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 6: Uso de VI y de VIM

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capitulo 7: Configuración de Bash

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 8: Sistema de Ficheros

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 9: Creando comandos

[Tabla de Contenidos](#tabla-de-contenidos)

-----

## Capítulo 10: Comandos Intermedios

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 11: Proot-Distro

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capitulo 12: Introducción a Sistemas Linux

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capitulo 13: Uso básico de Debian

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 14: Uso básico de Ubuntu

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 15: Uso básico de Alpine

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 16: Uso básico de Fedora

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 17: Introducción a Servicios

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 18: Creando un Servidor

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 19: Ngrok y Exponer Servicios

[Tabla de Contenidos](#tabla-de-contenidos)

----

## Capítulo 20: Tor, Configuración y Uso

[Tabla de Contenidos](#tabla-de-contenidos)

----
